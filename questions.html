<!DOCTYPE html>
<html lang="fr">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta name="google" content="notranslate" />
    <title>BAM Seminar - Questions</title>

    <link rel="icon" href="assets/img/apple-touch-icon.jpg" />
    <link rel="apple-touch-icon" href="assets/img/apple-touch-icon.jpg" />
    <link rel="shortcut icon" href="assets/img/favicon.ico" />

    <!-- iOS (ajoute aussi une icône 180x180) -->
    <link rel="apple-touch-icon" href="assets/img/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <script src="https://unpkg.com/@dotlottie/player-component@latest/dist/dotlottie-player.js"></script>

    <style>
      :root {
        --bg: #0f172a;
        --card: #111827;
        --muted: #94a3b8;
        --text: #e5e7eb;
        --accent: #60a5fa;
        --danger: #ef4444;
        --border: #1f2937;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial,
          sans-serif;
      }
      .wrap {
        max-width: 1100px;
        margin: 32px auto;
        padding: 0 16px;
      }
      h1 {
        font-size: 22px;
        margin: 0 0 14px;
      }
      .toolbar {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 14px;
      }
      .toolbar input[type="search"] {
        flex: 1;
        min-width: 220px;
        padding: 10px 12px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #0b1220;
        color: var(--text);
        outline: none;
      }
      .toolbar button {
        padding: 10px 12px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #0b1220;
        color: var(--text);
        cursor: pointer;
      }
      .toolbar button:hover {
        border-color: #334155;
      }
      .toolbar .primary {
        background: var(--accent);
        color: #0b1220;
        border-color: transparent;
      }
      .toolbar .danger {
        background: transparent;
        color: var(--danger);
      }
      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 12px;
        overflow: hidden;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      thead th {
        text-align: left;
        font-weight: 600;
        padding: 12px;
        background: #0b1220;
        border-bottom: 1px solid var(--border);
        user-select: none;
        cursor: pointer;
        position: sticky;
        top: 0;
        z-index: 1;
      }
      tbody td {
        padding: 12px;
        border-bottom: 1px solid var(--border);
        vertical-align: top;
      }
      tbody tr:hover {
        background: #0f1a2b;
      }
      .muted {
        color: var(--muted);
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 12px;
      }
      .right {
        margin-left: auto;
      }
      .status {
        margin-left: auto;
        color: var(--muted);
      }
      .empty {
        padding: 24px;
        text-align: center;
        color: var(--muted);
      }
      .pill {
        display: inline-block;
        padding: 2px 8px;
        border: 1px solid var(--border);
        border-radius: 999px;
        font-size: 12px;
        color: var(--muted);
      }
      .sortable:after {
        content: " ⇅";
        opacity: 0.5;
        font-weight: 400;
      }
      .sorted-asc:after {
        content: " ↑";
      }
      .sorted-desc:after {
        content: " ↓";
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Questions reçues <span id="count" class="pill">0</span></h1>

      <div class="toolbar">
        <input
          id="q"
          type="search"
          placeholder="Rechercher (nom, question, id)…"
        />
        <button id="refresh" class="primary">Rafraîchir</button>
        <!-- <button id="export" class="primary">Exporter CSV</button> -->
        <span id="status" class="status">—</span>
      </div>

      <div class="card">
        <table id="tbl">
          <thead>
            <tr>
              <th data-key="createdAt" class="sortable">Date</th>
              <th data-key="name" class="sortable">Nom</th>
              <th data-key="question" class="sortable">Question</th>
              <th>Traduction</th>
            </tr>
          </thead>
          <tbody id="tbody">
            <tr>
              <td colspan="4" class="empty">Chargement…</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <script>
      (function () {
        const API = "/api/questions";
        const tz = "Europe/Brussels";
        const fmt = new Intl.DateTimeFormat("fr-BE", {
          timeStyle: "short",
          timeZone: tz,
        });

        // --- Cache persistant pour traductions
        const LS_KEY = "qTranslationCacheV1";
        const translationCache = new Map();
        try {
          const saved = JSON.parse(localStorage.getItem(LS_KEY) || "{}");
          for (const [k, v] of Object.entries(saved))
            translationCache.set(k, v);
        } catch {}

        const $ = (sel) => document.querySelector(sel);
        const tbody = $("#tbody");
        const q = $("#q");
        const refreshBtn = $("#refresh");
        const exportBtn = $("#export");
        const countEl = $("#count");
        const statusEl = $("#status");
        const ths = Array.from(document.querySelectorAll("thead th[data-key]"));

        let rows = []; // toutes les données
        let view = []; // données filtrées + triées
        let sortKey = "createdAt";
        let sortDir = "desc"; // 'asc' | 'desc'
        let lastLoadedAt = null;

        function escapeHTML(s) {
          return (s || "").replace(
            /[&<>"']/g,
            (c) =>
              ({
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
              }[c])
          );
        }
        function setStatus(msg) {
          statusEl.textContent = msg;
        }

        async function load() {
          setStatus("Chargement…");
          try {
            const res = await fetch(API, { cache: "no-store" });
            const text = await res.text();
            const data = JSON.parse(text);
            rows = Array.isArray(data) ? data : [];
            countEl.textContent = rows.length;
            lastLoadedAt = new Date();
            setStatus(
              "MAJ: " +
                new Intl.DateTimeFormat("fr-BE", {
                  timeStyle: "medium",
                }).format(lastLoadedAt)
            );
            filterSortRender();
            // Lance les traductions nécessaires (uniquement NL, et pas celles déjà en cache)
            kickTranslations();
          } catch (e) {
            console.error(e);
            tbody.innerHTML = `<tr><td colspan="4" class="empty">❌ Erreur de chargement.</td></tr>`;
            setStatus("Erreur");
          }
        }

        function filterSortRender() {
          const term = q.value.trim().toLowerCase();

          // filtre (sans ID)
          view = rows.filter((r) => {
            const hay = [
              r.name || "",
              r.question || "",
              r.createdAt || "",
              translationCache.get(r.id)?.fr || "",
            ]
              .join(" ")
              .toLowerCase();
            return !term || hay.includes(term);
          });

          // tri
          view.sort((a, b) => {
            const A = a[sortKey] ?? "";
            const B = b[sortKey] ?? "";
            if (sortKey === "createdAt") {
              return sortDir === "asc"
                ? A.localeCompare(B)
                : B.localeCompare(A);
            }
            return sortDir === "asc"
              ? String(A).toLowerCase().localeCompare(String(B).toLowerCase())
              : String(B).toLowerCase().localeCompare(String(A).toLowerCase());
          });

          // rendu
          if (!view.length) {
            tbody.innerHTML = `<tr><td colspan="4" class="empty">Aucune question.</td></tr>`;
            return;
          }

          const html = view
            .map((it) => {
              const dStr = it.createdAt
                ? fmt.format(new Date(it.createdAt))
                : "";
              const cache = translationCache.get(it.id);
              const trText = cache?.fr
                ? escapeHTML(cache.fr)
                : `<span class="muted">—</span>`;
              const nlBadge =
                cache?.lang === "nl" && cache?.fr
                  ? ' <span class="pill">NL→FR</span>'
                  : "";
              const langBadge = cache?.lang
                ? ` <span class="pill">[${escapeHTML(cache.lang)}]</span>`
                : "";
              return `<tr>
        <td class="muted">${escapeHTML(dStr)}</td>
        <td>${escapeHTML(it.name ?? "")}</td>
        <td>${escapeHTML(it.question ?? "")}</td>
        <td>${trText}${nlBadge}${langBadge}</td>
      </tr>`;
            })
            .join("");

          tbody.innerHTML = html;

          // état tri header
          ths.forEach((th) => {
            th.classList.remove("sorted-asc", "sorted-desc");
            if (th.dataset.key === sortKey)
              th.classList.add(
                sortDir === "asc" ? "sorted-asc" : "sorted-desc"
              );
          });
        }

        // --- Heuristique NL locale : déclenche la traduction seulement si ça ressemble au néerlandais
        function looksDutch(text) {
          if (!text) return false;
          const s = text.toLowerCase();
          const rx = [
            // mots interrogatifs NL
            /\bwaar\b/,
            /\bwanneer\b/,
            /\bhoe\b/,
            /\bwat\b/,
            /\bwie\b/,
            /\bwaarom\b/,
            /\bwelke\b/,
            // mots fonctionnels fréquents
            /\bik\b/,
            /\bniet\b/,
            /\been\b/,
            /\bhet\b/,
            /\bde\b/,
            /\ben\b/,
            /\bje\b/,
            /\bjou\b/,
            /\bzijn\b/,
            /\bheb\b/,
            /\bhebt\b/,
            /\bmet\b/,
            /\bvoor\b/,
            /\bals\b/,
            /\bmaar\b/,
            /\bwel\b/,
            /\bgeen\b/,
            /\bgoed\b/,
            /\bdag\b/,
            /\bhallo\b/,
            /\bdank\b/,
            /\balstublieft\b/,
          ];
          let hits = 0;
          for (const r of rx) if (r.test(s)) hits++;
          return hits >= 2;
        }

        // --- Traductions (via ton backend /api/translate)
        async function kickTranslations() {
          const queue = [];
          for (const r of rows) {
            if (translationCache.has(r.id)) continue;
            if (!r.question) continue;

            // ne traduit que si NL probable (économise les requêtes)
            if (!looksDutch(r.question)) {
              translationCache.set(r.id, { lang: "other", fr: null });
              continue;
            }

            queue.push(
              (async () => {
                try {
                  const res = await fetch("/api/translate", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ text: r.question }),
                  });
                  const out = await res.json().catch(() => ({}));
                  translationCache.set(r.id, {
                    lang: out.lang || "nl",
                    fr: out.fr || null,
                  });
                  filterSortRender();
                } catch (e) {
                  console.debug("translate fail for id", r.id, e?.message || e);
                  translationCache.set(r.id, { lang: "nl", fr: null });
                }
              })()
            );

            if (queue.length >= 3) break; // limite 3 en parallèle
          }

          if (queue.length) {
            await Promise.allSettled(queue);
            // Sauvegarde le cache en localStorage
            try {
              const obj = Object.fromEntries(translationCache.entries());
              localStorage.setItem(LS_KEY, JSON.stringify(obj));
            } catch {}
          }
        }

        // Export CSV (sans ID)
        function toCSV(items) {
          const esc = (v) => `"${String(v ?? "").replace(/"/g, '""')}"`;
          const header = ["Date", "Nom", "Question", "Traduction_FR"];
          const lines = [header.join(",")];
          for (const it of items) {
            const d = it.createdAt ? fmt.format(new Date(it.createdAt)) : "";
            const tr = translationCache.get(it.id)?.fr || "";
            lines.push(
              [esc(d), esc(it.name), esc(it.question), esc(tr)].join(",")
            );
          }
          return lines.join("\n");
        }
        function downloadCSV() {
          const csv = toCSV(view);
          const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          const ts = new Date().toISOString().replace(/[:.]/g, "-");
          a.download = `questions-${ts}.csv`;
          document.body.appendChild(a);
          a.click();
          URL.revokeObjectURL(url);
          a.remove();
        }

        // events
        q.addEventListener("input", filterSortRender);
        refreshBtn.addEventListener("click", load);
        exportBtn.addEventListener("click", downloadCSV);
        ths.forEach((th) => {
          th.addEventListener("click", () => {
            const key = th.dataset.key;
            if (sortKey === key) {
              sortDir = sortDir === "asc" ? "desc" : "asc";
            } else {
              sortKey = key;
              sortDir = key === "createdAt" ? "desc" : "asc";
            }
            filterSortRender();
          });
        });

        // init (❌ plus d'auto-refresh 30s)
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", load);
        } else {
          load();
        }

        // (option) util pour réinitialiser le cache dans la console :
        // localStorage.removeItem('qTranslationCacheV1');
      })();
    </script>
  </body>
</html>
